name: Test Native Build Mingw-w64 on Ubuntu(2)

on:
  workflow_dispatch:
    inputs:
      gcc-version:
        description: 'GCC Version'
        required: true
        default: '13.2.0'

jobs:
  build-cross:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install System dependencies
        shell: bash
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
          FORCE_COLOR: '1'
        run: |
          set -euo pipefail

          export LOG_DIR="${GITHUB_WORKSPACE}/logs"
          mkdir -p "${LOG_DIR}"
          source "${GITHUB_WORKSPACE}/scripts/functions.sh"

          info "开始安装系统依赖（apt-get）"
          export DEBIAN_FRONTEND=noninteractive

          run "apt-get update" sudo apt-get update

          pkgs=( build-essential automake gettext autopoint pkg-config autoconf libtool m4 liblzma-dev nasm libgmp-dev libmpfr-dev libmpc-dev libisl-dev zlib1g-dev python3 python3-dev tcl tcl-dev )

          for p in "${pkgs[@]}"; do
            install_pkg "安装${p}包" "$p"
          done

          info "系统依赖安装完成"

      - name: Download Source Code
        shell: bash
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
          GCC_VERSION: ${{ github.event.inputs.gcc-version }}
          LOG_DIR: "${{ github.workspace }}/logs"
        run: |
          set -euo pipefail
          source "${GITHUB_WORKSPACE}/scripts/functions.sh"

          info "GCC 版本: ${GCC_VERSION}"
          DEP_JSON_FILE="${GITHUB_WORKSPACE}/dependencies.json"
          run "获取组件版本信息" export_versions_from_json "${DEP_JSON_FILE}" "${GCC_VERSION}" local

          export GITHUB_BASE_URL="https://github.com"
          export GNU_BASE_URL="https://ftp.gnu.org/gnu"

          # optional tuning
          export FORCE_COLOR=1
          mkdir -p "${LOG_DIR}"
          IGNORE_REGEX='array subscript 0 is outside array bounds'
          LOG_TAIL_LINES=80
          FAIL_ON_FATAL_IN_SUCCESS=1

          export SOURCE_CODE_DIR="${GITHUB_WORKSPACE}/source-code" && mkdir -p "${SOURCE_CODE_DIR}"

          gnu_pkgs=( gcc binutils libiconv make gdbm gdb )
          github_pkgs=( mingw-w64 ninja cmake pkgconf expat zlib python openssl sqlite libffi pdcurses )

          for p in "${gnu_pkgs[@]}";do
            if [[ "${p}" == "gcc" ]]; then
              ver="${GCC_VERSION}"
              echo "下载${p} 源码版本: ${ver}"
              run "下载${p}-${ver} 源码" curl_download "${GNU_BASE_URL}/${p}/${p}-${ver}/${p}-${ver}.tar.gz" "${SOURCE_CODE_DIR}"
              run "解压${p}-${ver} 源码" archive_extract "${p}" "${SOURCE_CODE_DIR}/${p}-${ver}.tar.gz" "${SOURCE_CODE_DIR}"
              # for d in gcc gmp mpfr mpc isl; do
              #   du -sh "${SOURCE_CODE_DIR}/${d}"
              # done
            else
              val="$(echo "$p" | tr '[:lower:]' '[:upper:]')"
              ver=${!val}
              run "下载${p}-${ver} 源码" curl_download "${GNU_BASE_URL}/${p}/${p}-${ver}.tar.gz" "${SOURCE_CODE_DIR}"
              run "解压${p}-${ver} 源码" archive_extract "${p}" "${SOURCE_CODE_DIR}/${p}-${ver}.tar.gz" "${SOURCE_CODE_DIR}"
              # du -sh "${SOURCE_CODE_DIR}/${p}"
            fi
          done
          for p in "${github_pkgs[@]}";do
            case "${p}" in
              mingw-w64)
                ver="${MINGW_W64}"
                github_author="mingw-w64"
                project_name="mingw-w64"
                ;;
              python)
                ver="${PYTHON}"
                github_author="msys2-contrib"
                project_name="cpython-mingw"
                ;;
              openssl|sqlite|libffi|pkgconf)
                pkg_name=${p^^}
                ver="${!pkg_name}"
                github_author="${p}"
                project_name="${p}"
                ;;
              ninja)
                ver="${NINJA}"
                github_author="ninja-build"
                project_name="ninja"
                ;;
              cmake)
                ver="${CMAKE}"
                github_author="Kitware"
                project_name="CMake"
                ;;
              expat)
                ver="${EXPAT}"
                github_author="libexpat"
                project_name="libexpat"
                ;;
              zlib)
                ver="${ZLIB}"
                github_author="madler"
                project_name="zlib"
                ;;
              pdcurses)
                ver="${PDCURSES}"
                github_author="wmcbrine"
                project_name="PDCurses"
                ;;
              *)
                error "未知的 GitHub 包: ${p}"
                exit 1
                ;;
            esac
            if [[ "${p}" == "sqlite" ]]; then
              echo "SQLITE_VERSION=${ver}" >> "${GITHUB_ENV}"
            fi
            if [[ "${p}" == "pkgconf" ]] || [[ "${p}" == "expat" ]] || [[ "${p}" == "libffi" ]] || [[ "${p}" == "openssl" ]] || [[ "${p}" == "cmake" ]]; then
              tail="${p}-${ver}.tar.gz"
            elif [[ "${p}" == "sqlite" ]]; then
              tail="version-${ver}.tar.gz"
            elif [[ "${p}" == "pdcurses" ]]; then
              tail="${ver}.tar.gz" # pdcurses
            else
              tail="v${ver}.tar.gz" # cpython-mingw zlib ninja
            fi
            if [[ "${p}" == "libffi" ]] || [[ "${p}" == "cmake" ]]; then
              TAG="v${ver}"
              URL="${GITHUB_BASE_URL}/${github_author}/${project_name}/releases/download/${TAG}/${tail}"
            elif [[ "${p}" == "expat" ]]; then
              EXPAT_TAG="R_${ver//./_}"
              URL="${GITHUB_BASE_URL}/${github_author}/${project_name}/releases/download/${EXPAT_TAG}/${tail}"
            else
              URL="${GITHUB_BASE_URL}/${github_author}/${project_name}/archive/refs/tags/${tail}"
            fi
            run "下载${p}-${ver} 源码" curl_download "${URL}" "${SOURCE_CODE_DIR}"
            run "解压${p}-${ver} 源码" archive_extract "${p}" "${SOURCE_CODE_DIR}/${tail}" "${SOURCE_CODE_DIR}"
            # if [[ -f "${SOURCE_CODE_DIR}/${tail}" ]]; then
            #   du -sh "${SOURCE_CODE_DIR}/${tail}"
            # fi
            # du -sh "${SOURCE_CODE_DIR}/${p}"
          done
          info "下载与解压步骤完成"

      - name: Build cross
        shell: bash
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
          GCC_VERSION: ${{ github.event.inputs.gcc-version }}
        run: |
          set -euo pipefail
          source "${GITHUB_WORKSPACE}/scripts/functions.sh"

          # tuning
          export LOG_DIR="${GITHUB_WORKSPACE}/logs"
          export FORCE_COLOR=1
          mkdir -p "${LOG_DIR}"
          IGNORE_REGEX='array subscript 0 is outside array bounds'
          LOG_TAIL_LINES=120
          FAIL_ON_FATAL_IN_SUCCESS=1

          export SOURCE_CODE_DIR="${GITHUB_WORKSPACE}/source-code"
          export BUILD_DIR="${GITHUB_WORKSPACE}/build-cross"
          export PREFIX="${GITHUB_WORKSPACE}/mingw-w64-cross"

          # prepare dirs
          for d in "${BUILD_DIR}" "${PREFIX}"; do
            if [ -d "${d}" ]; then
              run "清理目录 ${d}" rm -rf "${d}"
            fi
            run "创建目录 ${d}" mkdir -p "${d}"
          done

          cd "${BUILD_DIR}"

          export BUILD="x86_64-pc-linux-gnu"
          export HOST="x86_64-pc-linux-gnu"
          export TARGET="x86_64-w64-mingw32"

          pkgs=( binutils libiconv make termcap ncurses readline gdbm gdb python openssl sqlite ninja cmake libffi pkgconf expat )
          info "准备清理环境变量"
          for p in "${pkgs[@]}"; do
            val="$(echo "$p" | tr '[:lower:]' '[:upper:]')"
            unset "${val}"
          done
          unset MINGW_W64 gcc_version

          # binutils
          run "构建 binutils: configure" mkdir -p "${BUILD_DIR}/binutils-build"
          cd "${BUILD_DIR}/binutils-build"
          run "binutils: configure" "${SOURCE_CODE_DIR}/binutils/configure" \
            --prefix="${PREFIX}" \
            --target="${TARGET}" \
            --host="${HOST}" \
            --build="${BUILD}" \
            --disable-multilib \
            --disable-werror
          run "binutils: make" make -j$(nproc)
          run "binutils: make install" make install

          export PATH="${PREFIX}/bin:${PATH}"

          # mingw headers
          run "构建 mingw-w64 headers: setup dir" mkdir -p "${BUILD_DIR}/mingw-headers-build"
          cd "${BUILD_DIR}/mingw-headers-build"
          run "mingw-headers: configure" "${SOURCE_CODE_DIR}/mingw-w64/mingw-w64-headers/configure" --prefix="${PREFIX}/${TARGET}" --host="${TARGET}" --build="${BUILD}" --enable-sdk=all --enable-secure-api --enable-idl --disable-multilib
          run "mingw-headers: make" make -j$(nproc)
          run "mingw-headers: install" make install
          run "ls prefix target dir" ls -l "${PREFIX}/${TARGET}/"
          run "ensure mingw include symlink" bash -lc 'mkdir -p "'"${PREFIX}/${TARGET}/mingw"'" && ln -sfn "'"${PREFIX}/${TARGET}/include"'" "'"${PREFIX}/${TARGET}/mingw/include"'"'

          # gcc stage1
          run "准备 gcc stage1 build dir" mkdir -p "${BUILD_DIR}/gcc-stage1-build"
          cd "${BUILD_DIR}/gcc-stage1-build"
          run "gcc stage1: configure" "${SOURCE_CODE_DIR}/gcc/configure" \
            --prefix="${PREFIX}" \
            --target="${TARGET}" \
            --host="${HOST}" \
            --build="${BUILD}" \
            --disable-multilib \
            --enable-languages=c \
            --without-headers \
            --disable-shared \
            --disable-threads \
            --disable-libatomic \
            --disable-libgomp \
            --disable-libquadmath \
            --disable-libssp \
            --disable-libvtv \
            --disable-libstdcxx \
            --disable-nls \
            --with-gmp=/usr \
            --with-mpfr=/usr \
            --with-mpc=/usr \
            --with-isl=/usr

          run "gcc stage1: make all-gcc" make -j$(nproc) all-gcc
          run "gcc stage1: install-gcc" make install-gcc

          # set cross toolchain env
          export CC="${PREFIX}/bin/${TARGET}-gcc"
          export CXX="${PREFIX}/bin/${TARGET}-g++"
          export LD="${PREFIX}/bin/${TARGET}-ld"
          export AR="${PREFIX}/bin/${TARGET}-ar"
          export AS="${PREFIX}/bin/${TARGET}-as"
          export RANLIB="${PREFIX}/bin/${TARGET}-ranlib"

          # mingw-crt
          run "prepare mingw-crt build dir" mkdir -p "${BUILD_DIR}/mingw-crt-build"
          cd "${BUILD_DIR}/mingw-crt-build"
          run "mingw-crt: configure" "${SOURCE_CODE_DIR}/mingw-w64/mingw-w64-crt/configure" --prefix="${PREFIX}/${TARGET}" --host="${TARGET}" --build="${BUILD}" --disable-multilib --with-sysroot="${PREFIX}/${TARGET}"
          run "mingw-crt: make" make -j$(nproc)
          run "mingw-crt: install" make install

          # gcc full build
          run "取消 cross 工具链环境变量" unset CC CXX LD AR AS RANLIB
          run "准备 gcc full build dir" mkdir -p "${BUILD_DIR}/gcc-full-build"
          cd "${BUILD_DIR}/gcc-full-build"
          run "gcc full: configure" "${SOURCE_CODE_DIR}/gcc/configure" \
            --prefix="${PREFIX}" \
            --target="${TARGET}" \
            --host="${HOST}" \
            --build="${BUILD}" \
            --disable-multilib \
            --enable-languages=c,c++,fortran \
            --enable-threads=win32 \
            --enable-shared \
            --enable-static \
            --with-sysroot="${PREFIX}/${TARGET}" \
            --disable-nls \
            --with-gmp=/usr \
            --with-mpfr=/usr \
            --with-mpc=/usr \
            --with-isl=/usr

          export CC="${PREFIX}/bin/${TARGET}-gcc"
          export CXX="${PREFIX}/bin/${TARGET}-g++"
          export LD="${PREFIX}/bin/${TARGET}-ld"
          export AR="${PREFIX}/bin/${TARGET}-ar"
          export AS="${PREFIX}/bin/${TARGET}-as"
          export RANLIB="${PREFIX}/bin/${TARGET}-ranlib"

          run "gcc full: make" make -j$(nproc)
          run "gcc full: install" make install

          info "交叉编译工具链构建完成！"
          info "工具链已安装到：${PREFIX}"
          run "清除构建目录以节省空间" rm -rf "${BUILD_DIR}"

          # 最后：生成聚合 summary 并打印路径（actions 后续可上传）
          agg="$(aggregate_all_summaries)"
          info "聚合摘要已写入：$agg"

      - name: Build native
        shell: bash
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
          GCC_VERSION: ${{ github.event.inputs.gcc-version }}
        run: |
          set -euo pipefail
          source "${GITHUB_WORKSPACE}/scripts/functions.sh"

          # params / tuning
          export SOURCE_CODE_DIR="${GITHUB_WORKSPACE}/source-code"
          export BUILD_DIR="${GITHUB_WORKSPACE}/build-native"
          export CROSS_PREFIX="${GITHUB_WORKSPACE}/mingw-w64-cross"
          export PREFIX="${GITHUB_WORKSPACE}/mingw-w64-native"

          export BUILD="x86_64-pc-linux-gnu"
          export HOST="x86_64-w64-mingw32"
          export TARGET="x86_64-w64-mingw32"

          # 定义子目录
          export OPT_DIR="${PREFIX}/opt"
          export TARGET_DIR="${PREFIX}/${TARGET}"
          export SHARE_DIR="${PREFIX}/share"

          export LOG_DIR="${GITHUB_WORKSPACE}/logs"
          export FORCE_COLOR=1
          mkdir -p "${LOG_DIR}"

          export CFLAGS="-O2 -pipe -fno-ident"
          export CXXFLAGS="${CFLAGS}"
          export LDFLAGS="-pipe -fno-ident"
          export CPPFLAGS=""

          IGNORE_REGEX='array subscript 0 is outside array bounds'
          LOG_TAIL_LINES=300
          FAIL_ON_FATAL_IN_SUCCESS=1

          # 创建所有必要的目录
          for d in "${BUILD_DIR}" "${PREFIX}" "${OPT_DIR}" "${SHARE_DIR}" "${TARGET_DIR}"; do
            if [ -d "${d}" ]; then
              run "清理目录 ${d}" rm -rf "${d}"
            fi
            run "创建目录 ${d}" mkdir -p "${d}"
          done
          pkgs=( binutils libiconv make termcap ncurses readline gdbm gdb python openssl sqlite ninja cmake libffi pkgconf expat )
          info "准备清理环境变量"
          for p in "${pkgs[@]}"; do
            val="$(echo "$p" | tr '[:lower:]' '[:upper:]')"
            unset "${val}"
          done
          unset MINGW_W64 gcc_version

          cd "${BUILD_DIR}"

          # triples and PATH (use cross toolchain to build mingw-native artifacts)
          export PATH="${CROSS_PREFIX}/bin:${PATH}"

          # 工具链编译器
          export CC="${CROSS_PREFIX}/bin/${TARGET}-gcc"
          export CXX="${CROSS_PREFIX}/bin/${TARGET}-g++"
          export LD="${CROSS_PREFIX}/bin/${TARGET}-ld"
          export AR="${CROSS_PREFIX}/bin/${TARGET}-ar"
          export AS="${CROSS_PREFIX}/bin/${TARGET}-as"
          export RANLIB="${CROSS_PREFIX}/bin/${TARGET}-ranlib"
          export STRIP="${CROSS_PREFIX}/bin/${TARGET}-strip"
          export WINDRES="${CROSS_PREFIX}/bin/${TARGET}-windres"
          export FC="${CROSS_PREFIX}/bin/${TARGET}-gfortran"

          # =========== 1. 核心数学库依赖 (安装到 ${PREFIX}) ===========
          # =========== 3. mingw-w64 头文件 (安装到 ${TARGET_DIR}) ===========
          run "准备 mingw-headers build dir" mkdir -p "${BUILD_DIR}/mingw-headers-build"
          cd "${BUILD_DIR}/mingw-headers-build"
          run "mingw-headers: configure" "${SOURCE_CODE_DIR}/mingw-w64/mingw-w64-headers/configure" \
            --prefix="${TARGET_DIR}" \
            --host="${TARGET}" \
            --build="${BUILD}" \
            --enable-sdk=all \
            --enable-secure-api \
            --enable-idl \
            --disable-multilib \
            CFLAGS="${CFLAGS}" \
            CXXFLAGS="${CXXFLAGS}" \
            LDFLAGS="${LDFLAGS}" \
            CPPFLAGS="${CPPFLAGS}"
          run "mingw-headers: make" make -j$(nproc)
          run "mingw-headers: install" make install

          # ensure include symlink
          run "ensure mingw include symlink" bash -lc 'mkdir -p "'"${TARGET_DIR}/mingw"'" && ln -sfn "'"${TARGET_DIR}/include"'" "'"${TARGET_DIR}/mingw/include"'"'

          # =========== 2. libiconv (安装到 ${PREFIX}) ===========
          # libiconv (Windows原生版本)
          run "准备 libiconv build dir" mkdir -p "${BUILD_DIR}/libiconv-build"
          cd "${BUILD_DIR}/libiconv-build"
          run "libiconv: configure" "${SOURCE_CODE_DIR}/libiconv/configure" \
            --prefix="${TARGET_DIR}" \
            --host="${HOST}" \
            --build="${BUILD}" \
            --enable-static \
            --disable-shared \
            --disable-nls \
            CFLAGS="${CFLAGS}" \
            CXXFLAGS="${CXXFLAGS}" \
            LDFLAGS="${LDFLAGS}" \
            CPPFLAGS="${CPPFLAGS}"
          run "libiconv: make" make -j$(nproc)
          run "libiconv: make install" make install
          # 这些是gcc的直接依赖，需要安装在主目录
          for d in gmp mpfr mpc isl; do
            run "准备 ${d} build dir" mkdir -p "${BUILD_DIR}/${d}-build"
            cd "${BUILD_DIR}/${d}-build"

            DEP_FLAGS=""
            if [[ "$d" == "mpfr" ]]; then
              DEP_FLAGS="--with-gmp=${PREFIX}"
            elif [[ "$d" == "mpc" ]]; then
              DEP_FLAGS="--with-gmp=${PREFIX} --with-mpfr=${PREFIX}"
            elif [[ "$d" == "isl" ]]; then
              DEP_FLAGS="--with-gmp-prefix=${PREFIX}"
            fi

            run "${d}: configure" "${SOURCE_CODE_DIR}/${d}/configure" \
              --prefix="${PREFIX}" \
              --host="${HOST}" \
              --build="${BUILD}" \
              ${DEP_FLAGS} \
              --enable-static \
              --disable-shared \
              CFLAGS="${CFLAGS}" \
              CXXFLAGS="${CXXFLAGS}" \
              LDFLAGS="${LDFLAGS}" \
              CPPFLAGS="${CPPFLAGS}"

            run "${d}: make" make -j$(nproc)
            run "${d}: make install" make install
          done

          # =========== build zlib static ======================
          run "准备 zlib build dir" mkdir -p "${BUILD_DIR}/zlib-build"
          cd "${BUILD_DIR}/zlib-build"
          run "zlib: configure" "${SOURCE_CODE_DIR}/zlib/configure" \
            --prefix="${OPT_DIR}" \
            --static
          run "zlib: make" make -j$(nproc)
          run "zlib: make install" make install

          export ZLIB_INCLUDE="${OPT_DIR}/include"
          export ZLIB_LIB="${OPT_DIR}/lib"

          export CFLAGS="${CFLAGS} -I${ZLIB_INCLUDE}"
          export CXXFLAGS="${CXXFLAGS} -I${ZLIB_INCLUDE}"
          export LDFLAGS="${LDFLAGS} -L${ZLIB_LIB}"
          export CPPFLAGS="-I${ZLIB_INCLUDE}"

          # =========== 2. binutils (安装到 ${PREFIX}) ===========
          run "准备 binutils build dir" mkdir -p "${BUILD_DIR}/binutils-build"
          cd "${BUILD_DIR}/binutils-build"
          run "binutils: configure" "${SOURCE_CODE_DIR}/binutils/configure" \
            --prefix="${PREFIX}" \
            --host="${HOST}" \
            --build="${BUILD}" \
            --target="${TARGET}" \
            --disable-werror \
            --enable-lto \
            --enable-plugins \
            --with-sysroot="${TARGET_DIR}" \
            --enable-install-libiberty \
            --disable-nls \
            --disable-rpath \
            --enable-host-shared=no \
            CFLAGS="${CFLAGS}" \
            CXXFLAGS="${CXXFLAGS}" \
            LDFLAGS="${LDFLAGS}" \
            CPPFLAGS="${CPPFLAGS}"
          run "binutils: make" make -j$(nproc)
          run "binutils: make install" make install

          # # =========== 4. gcc 第一阶段 (bootstrap) ===========
          # run "准备 gcc stage1 build dir" mkdir -p "${BUILD_DIR}/gcc1-build"
          # cd "${BUILD_DIR}/gcc1-build"
          # run "gcc stage1: configure" "${SOURCE_CODE_DIR}/gcc/configure" \
          #   --prefix="${PREFIX}" \
          #   --host="${HOST}" \
          #   --build="${BUILD}" \
          #   --target="${TARGET}" \
          #   --disable-multilib \
          #   --enable-languages=c,c++ \
          #   --without-headers \
          #   --disable-shared \
          #   --disable-threads \
          #   --disable-libatomic \
          #   --disable-libgomp \
          #   --disable-libquadmath \
          #   --disable-libssp \
          #   --disable-libvtv \
          #   --disable-libstdcxx \
          #   --disable-nls \
          #   --with-gmp="${PREFIX}" \
          #   --with-mpfr="${PREFIX}" \
          #   --with-mpc="${PREFIX}" \
          #   --with-isl="${PREFIX}" \
          #   --with-sysroot="${TARGET_DIR}" \
          #   CFLAGS="${CFLAGS}" \
          #   CXXFLAGS="${CXXFLAGS}" \
          #   LDFLAGS="${LDFLAGS}" \
          #   CPPFLAGS="${CPPFLAGS}"

          # run "gcc stage1: make all-gcc" make -j$(nproc) all-gcc
          # run "gcc stage1: make install-gcc" make install-gcc

          # =========== 5. mingw-w64 CRT (安装到 ${TARGET_DIR}) ===========
          run "准备 mingw-crt build dir" mkdir -p "${BUILD_DIR}/mingw-crt-build"
          cd "${BUILD_DIR}/mingw-crt-build"
          run "mingw-crt: configure" "${SOURCE_CODE_DIR}/mingw-w64/mingw-w64-crt/configure" \
            --prefix="${TARGET_DIR}" \
            --host="${TARGET}" \
            --build="${BUILD}" \
            --with-sysroot="${TARGET_DIR}" \
            --disable-multilib \
            CFLAGS="${CFLAGS}" \
            CXXFLAGS="${CXXFLAGS}" \
            LDFLAGS="${LDFLAGS}" \
            CPPFLAGS="${CPPFLAGS}"
          run "mingw-crt: make" make -j$(nproc)
          run "mingw-crt: install" make install

          # =========== mingw-w64-winpthreads =================
          run "准备 mingw-w64-winpthreads build dir" mkdir -p "${BUILD_DIR}/mingw-w64-winpthreads-build"
          cd "${BUILD_DIR}/mingw-w64-winpthreads-build"
          run "mingw-w64-winpthreads: configure" "${SOURCE_CODE_DIR}/mingw-w64/mingw-w64-libraries/winpthreads/configure" \
            --prefix="${TARGET_DIR}" \
            --host="${TARGET}" \
            --build="${BUILD}" \
            --with-sysroot="${TARGET_DIR}" \
            --enable-static \
            --enable-shared \
            --disable-multilib \
            CFLAGS="${CFLAGS}" \
            CXXFLAGS="${CXXFLAGS}" \
            LDFLAGS="${LDFLAGS}" \
            CPPFLAGS="${CPPFLAGS}"

          run "mingw-w64-winpthreads: make" make -j$(nproc)
          run "mingw-w64-winpthreads: install" make install

          # =========== 12. mingw-w64 其他库 ===========
          # libmangle (安装到 ${TARGET_DIR})
          run "准备 mingw-w64-libmangle build dir" mkdir -p "${BUILD_DIR}/mingw-w64-libmangle-build"
          cd "${BUILD_DIR}/mingw-w64-libmangle-build"
          run "mingw-w64-libmangle: configure" "${SOURCE_CODE_DIR}/mingw-w64/mingw-w64-libraries/libmangle/configure" \
            --prefix="${TARGET_DIR}" \
            --host="${TARGET}" \
            --build="${BUILD}" \
            CFLAGS="${CFLAGS}" \
            CXXFLAGS="${CXXFLAGS}" \
            LDFLAGS="${LDFLAGS}" \
            CPPFLAGS="${CPPFLAGS}"
          run "mingw-w64-libmangle: make" make -j$(nproc)
          run "mingw-w64-libmangle: install" make install

          # tools (包含 widl 等工具，安装到 ${PREFIX})
          for p in gendef genidl genpeimg widl; do
            run "准备 mingw-w64-tools ${p} build dir" mkdir -p "${BUILD_DIR}/mingw-w64-tools-${p}-build"
            cd "${BUILD_DIR}/mingw-w64-tools-${p}-build"
            run "mingw-w64-tools: configure" "${SOURCE_CODE_DIR}/mingw-w64/mingw-w64-tools/${p}/configure" \
              --prefix="${PREFIX}" \
              --host="${HOST}" \
              --build="${BUILD}" \
              --with-sysroot="${TARGET_DIR}" \
              CFLAGS="${CFLAGS}" \
              CXXFLAGS="${CXXFLAGS}" \
              LDFLAGS="${LDFLAGS}" \
              CPPFLAGS="${CPPFLAGS}"
            run "mingw-w64-tools ${p} : make" make -j$(nproc)
            run "mingw-w64-tools ${p} : install" make install
          done

          # =========== 13. gcc 第二阶段 (完整版本) ===========
          run "恢复使用新构建的binutils" export PATH="${PREFIX}/bin:${PATH}"
          run "准备 gcc stage2 build dir" mkdir -p "${BUILD_DIR}/gcc2-build"
          cd "${BUILD_DIR}/gcc2-build"
          # info "取消 cross 工具链环境变量"
          # unset CC CXX LD AR AS RANLIB
          run "gcc stage2: configure" "${SOURCE_CODE_DIR}/gcc/configure" \
            --prefix="${PREFIX}" \
            --host="${HOST}" \
            --build="${BUILD}" \
            --target="${TARGET}" \
            --enable-languages=c,c++,fortran \
            --enable-shared \
            --enable-static \
            --enable-threads=win32 \
            --enable-lto \
            --enable-plugins \
            --disable-nls \
            --disable-multilib \
            --with-gmp="${PREFIX}" \
            --with-mpfr="${PREFIX}" \
            --with-mpc="${PREFIX}" \
            --with-isl="${PREFIX}" \
            --with-system-zlib \
            --with-sysroot="${TARGET_DIR}" \
            --with-boot-ldflags="-Wl,--disable-dynamicbase -static-libstdc++ -static-libgcc" \
            CFLAGS="${CFLAGS}" \
            CXXFLAGS="${CXXFLAGS}" \
            LDFLAGS="${LDFLAGS}" \
            CPPFLAGS="${CPPFLAGS}"

          # 设置使用新构建的gcc作为编译器
          export CC="${CROSS_PREFIX}/bin/${TARGET}-gcc"
          export CXX="${CROSS_PREFIX}/bin/${TARGET}-g++"
          export LD="${CROSS_PREFIX}/bin/${TARGET}-ld"
          export AR="${CROSS_PREFIX}/bin/${TARGET}-ar"
          export AS="${CROSS_PREFIX}/bin/${TARGET}-as"
          export RANLIB="${CROSS_PREFIX}/bin/${TARGET}-ranlib"
          export STRIP="${CROSS_PREFIX}/bin/${TARGET}-strip"
          export WINDRES="${CROSS_PREFIX}/bin/${TARGET}-windres"
          export FC="${CROSS_PREFIX}/bin/${TARGET}-gfortran"

          run "gcc stage2: make" make -j$(nproc)
          run "gcc stage2: make install" make install

          run "删除多余链接目录" rm -rf "${TARGET_DIR}/mingw"

          cd "${PREFIX}" || exit 1

          echo "== Strip exe / dll =="
          find . -type f \( -name '*.exe' -o -name '*.dll' \) -print0 |
            xargs -0 -n1 "${CROSS_PREFIX}/bin/${TARGET}-strip" --strip-unneeded || true

          echo "== Strip static libraries =="
          find . -type f -name '*.a' -print0 |
            xargs -0 -n1 "${CROSS_PREFIX}/bin/${TARGET}-strip" --strip-debug || true

          echo "== Remove libtool artifacts =="
          find . -type f -name '*.la' -delete

          echo "== Remove stray debug files (if any) =="
          find . -type f -name '*.debug' -delete

      - name: Tree Native dir
        shell: bash
        run: |
          echo "原生工具链目录结构:"
          tree -L 3 "${GITHUB_WORKSPACE}/mingw-w64-native" || true

      - name: upload logs
        if: always() || cancelled() || failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: "${{ github.workspace }}/logs"

      - name: upload native toolchain
        uses: actions/upload-artifact@v4
        with:
          name: mingw-w64-native-toolchain
          path: "${{ github.workspace }}/mingw-w64-native"

  # build-Extension-components:
  #   needs: build-cross
  #   runs-on: windows-latest
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v3

  #     - name: Download mingw-w64-native-toolchain
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: mingw-w64-native-toolchain
  #         path: "${{ github.workspace }}/mingw-w64-native"

  #     - name: download source code
  #       shell: pwsh
  #       run: |

