name: Test Build Mingw-w64 on Ubuntu(2)

on:
  workflow_dispatch:
    inputs:
      gcc-version:
        description: 'GCC Version'
        required: true
        default: '13.2.0'

jobs:
  build-cross:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install System dependencies
        shell: bash
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
          FORCE_COLOR: '1'
        run: |
          set -euo pipefail

          export LOG_DIR="${GITHUB_WORKSPACE}/logs"
          mkdir -p "${LOG_DIR}"
          source "${GITHUB_WORKSPACE}/scripts/functions.sh"

          info "开始安装系统依赖（apt-get）"
          export DEBIAN_FRONTEND=noninteractive

          run "apt-get update" sudo apt-get update

          pkgs=( build-essential liblzma-dev nasm libgmp-dev libmpfr-dev libmpc-dev libisl-dev )

          for p in "${pkgs[@]}"; do
            install_pkg "安装${p}包" "$p"
          done

          # 检查已安装的版本
          apt list --installed | grep -E "(gmp|mpfr|mpc|isl)"
          find / -name "mpfr.h" 2>/dev/null
          find / -name "gmp.h" 2>/dev/null
          find / -name "mpc.h" 2>/dev/null
          find / -name "isl.h" 2>/dev/null
          info "系统依赖安装完成"

      # - name: Get Dependencies Version
      #   id: get-versions
      #   shell: bash
      #   env:
      #     GITHUB_WORKSPACE: ${{ github.workspace }}
      #     GCC_VERSION: ${{ github.event.inputs.gcc-version }}
      #     DEP_ISON_FILE: "${{ github.workspace }}/dependencies.json"
      #   run: |
      #     set -euo pipefail
      #     source "${GITHUB_WORKSPACE}/scripts/functions.sh"
      #     info "GCC 版本: ${GCC_VERSION}"
      #     run "获取组件版本信息" export_versions_from_json "${DEP_ISON_FILE}" "${GCC_VERSION}" env

      # - name: Download Source Code
      #   shell: bash
      #   env:
      #     GITHUB_WORKSPACE: ${{ github.workspace }}
      #     GCC_VERSION: ${{ github.event.inputs.gcc-version }}
      #     LOG_DIR: "${{ github.workspace }}/logs"
      #   run: |
      #     set -euo pipefail
      #     source "${GITHUB_WORKSPACE}/scripts/functions.sh"

      #     export GITHUB_BASE_URL="https://github.com"
      #     export GNU_BASE_URL="https://ftp.gnu.org/gnu"

      #     # optional tuning
      #     export FORCE_COLOR=1
      #     mkdir -p "${LOG_DIR}"
      #     IGNORE_REGEX='array subscript 0 is outside array bounds'
      #     LOG_TAIL_LINES=80
      #     FAIL_ON_FATAL_IN_SUCCESS=1

      #     export SOURCE_CODE_DIR="${GITHUB_WORKSPACE}/source-code" && mkdir -p "${SOURCE_CODE_DIR}"

      #     gnu_pkgs=( gcc binutils libiconv make termcap ncurses readline gdbm gdb )
      #     github_pkgs=( mingw-w64 python openssl sqlite ninja cmake libffi pkgconf expat )

      #     for p in "${gnu_pkgs[@]}";do
      #       if [[ "${p}" == "gcc" ]]; then
      #         ver="${GCC_VERSION}"
      #         echo "下载${p} 源码版本: ${ver}"
      #         run "下载${p}-${ver} 源码" curl_download "${GNU_BASE_URL}/${p}/${p}-${ver}/${p}-${ver}.tar.gz" "${SOURCE_CODE_DIR}"
      #         run "解压${p}-${ver} 源码" archive_extract "${p}" "${SOURCE_CODE_DIR}/${p}-${ver}.tar.gz" "${SOURCE_CODE_DIR}"
      #       else
      #         val="$(echo "$p" | tr '[:lower:]' '[:upper:]')"
      #         ver=${!val}
      #         run "下载${p}-${ver} 源码" curl_download "${GNU_BASE_URL}/${p}/${p}-${ver}.tar.gz" "${SOURCE_CODE_DIR}"
      #         run "解压${p}-${ver} 源码" archive_extract "${p}" "${SOURCE_CODE_DIR}/${p}-${ver}.tar.gz" "${SOURCE_CODE_DIR}"
      #       fi
      #     done
      #     for p in "${github_pkgs[@]}";do
      #       case "${p}" in
      #         mingw-w64)
      #           ver="${MINGW_W64}"
      #           github_author="mingw-w64"
      #           project_name="mingw-w64"
      #           ;;
      #         python)
      #           ver="${PYTHON}"
      #           github_author="python"
      #           project_name="cpython"
      #           ;;
      #         openssl|sqlite|libffi|pkgconf)
      #           pkg_name=${p^^}
      #           ver="${!pkg_name}"
      #           github_author="${p}"
      #           project_name="${p}"
      #           ;;
      #         ninja)
      #           ver="${NINJA}"
      #           github_author="ninja-build"
      #           project_name="ninja"
      #           ;;
      #         cmake)
      #           ver="${CMAKE}"
      #           github_author="Kitware"
      #           project_name="CMake"
      #           ;;
      #         expat)
      #           ver="${EXPAT}"
      #           github_author="libexpat"
      #           project_name="libexpat"
      #           ;;
      #         *)
      #           error "未知的 GitHub 包: ${p}"
      #           exit 1
      #           ;;
      #       esac
      #       if [[ "${p}" == "openssl" ]] || [[ "${p}" == "pkgconf" ]]; then
      #         tail="${p}-${ver}.tar.gz"
      #       elif [[ "${p}" == "sqlite" ]]; then
      #         tail="version-${ver}.tar.gz"
      #       elif [[ "${p}" == "expat" ]]; then
      #         tail="R_${ver//./_}.tar.gz"
      #       else
      #         tail="v${ver}.tar.gz"
      #       fi
      #       run "下载${p}-${ver} 源码" curl_download "${GITHUB_BASE_URL}/${github_author}/${project_name}/archive/refs/tags/${tail}" "${SOURCE_CODE_DIR}"
      #       run "解压${p}-${ver} 源码" archive_extract "${p}" "${SOURCE_CODE_DIR}/${tail}" "${SOURCE_CODE_DIR}"
      #     done

      #     info "下载与解压步骤完成"

      # - name: Build cross
      #   shell: bash
      #   env:
      #     GITHUB_WORKSPACE: ${{ github.workspace }}
      #     GCC_VERSION: ${{ github.event.inputs.gcc-version }}
      #   run: |
      #     set -euo pipefail
      #     source "${GITHUB_WORKSPACE}/scripts/functions.sh"

      #     # tuning
      #     export LOG_DIR="${GITHUB_WORKSPACE}/logs"
      #     export FORCE_COLOR=1
      #     mkdir -p "${LOG_DIR}"
      #     IGNORE_REGEX='array subscript 0 is outside array bounds'
      #     LOG_TAIL_LINES=120
      #     FAIL_ON_FATAL_IN_SUCCESS=1

      #     export SOURCE_CODE_DIR="${GITHUB_WORKSPACE}/source-code"
      #     export BUILD_DIR="${GITHUB_WORKSPACE}/build-cross"
      #     export PREFIX="${GITHUB_WORKSPACE}/mingw-w64-cross"

      #     # prepare dirs
      #     for d in "${BUILD_DIR}" "${PREFIX}"; do
      #       if [ -d "${d}" ]; then
      #         run "清理目录 ${d}" rm -rf "${d}"
      #       fi
      #       run "创建目录 ${d}" mkdir -p "${d}"
      #     done

      #     cd "${BUILD_DIR}"

      #     export BUILD="x86_64-pc-linux-gnu"
      #     export HOST="x86_64-pc-linux-gnu"
      #     export TARGET="x86_64-w64-mingw32"

      #     pkgs=( binutils libiconv make termcap ncurses readline gdbm gdb mingw-w64 python openssl sqlite ninja cmake libffi pkgconf expat )
      #     for p in "${pkgs[@]}"; do
      #       val="$(echo "$p" | tr '[:lower:]' '[:upper:]')"
      #       info "准备取消相关环境变量 ${val}"
      #       unset "${val}"
      #     done
      #     unset MINGW_W64 gcc_version

      #     # binutils
      #     run "构建 binutils: configure" mkdir -p "${BUILD_DIR}/binutils-build" && cd "${BUILD_DIR}/binutils-build"
      #     run "binutils: configure" "${SOURCE_CODE_DIR}/binutils/configure" --prefix="${PREFIX}" --target="${TARGET}" --host="${HOST}" --build="${BUILD}" --disable-multilib --disable-werror
      #     run "binutils: make" make -j$(nproc)
      #     run "binutils: make install" make install

      #     export PATH="${PREFIX}/bin:${PATH}"

      #     # mingw headers
      #     run "构建 mingw-w64 headers: setup dir" mkdir -p "${BUILD_DIR}/mingw-headers-build" && cd "${BUILD_DIR}/mingw-headers-build"
      #     run "mingw-headers: configure" "${SOURCE_CODE_DIR}/mingw-w64/mingw-w64-headers/configure" --prefix="${PREFIX}/${TARGET}" --host="${TARGET}" --build="${BUILD}" --enable-sdk=all --enable-secure-api --enable-idl --disable-multilib
      #     run "mingw-headers: make" make -j$(nproc)
      #     run "mingw-headers: install" make install
      #     run "ls prefix target dir" ls -l "${PREFIX}/${TARGET}/"
      #     run "ensure mingw include symlink" bash -lc 'mkdir -p "'"${PREFIX}/${TARGET}/mingw"'" && ln -sfn "'"${PREFIX}/${TARGET}/include"'" "'"${PREFIX}/${TARGET}/mingw/include"'"'

      #     # gcc stage1
      #     run "准备 gcc stage1 build dir" mkdir -p "${BUILD_DIR}/gcc-stage1-build" && cd "${BUILD_DIR}/gcc-stage1-build"
      #     run "gcc stage1: configure" "${SOURCE_CODE_DIR}/gcc/configure" \
      #       --prefix="${PREFIX}" \
      #       --target="${TARGET}" \
      #       --host="${HOST}" \
      #       --build="${BUILD}" \
      #       --disable-multilib \
      #       --enable-languages=c \
      #       --without-headers \
      #       --disable-shared \
      #       --disable-threads \
      #       --disable-libatomic \
      #       --disable-libgomp \
      #       --disable-libquadmath \
      #       --disable-libssp \
      #       --disable-libvtv \
      #       --disable-libstdcxx \
      #       --disable-nls \
      #       --with-gmp=/usr \
      #       --with-mpfr=/usr \
      #       --with-mpc=/usr \
      #       --with-isl=/usr

      #     run "gcc stage1: make all-gcc" make -j$(nproc) all-gcc
      #     run "gcc stage1: install-gcc" make install-gcc

      #     # set cross toolchain env
      #     export CC="${PREFIX}/bin/${TARGET}-gcc"
      #     export CXX="${PREFIX}/bin/${TARGET}-g++"
      #     export LD="${PREFIX}/bin/${TARGET}-ld"
      #     export AR="${PREFIX}/bin/${TARGET}-ar"
      #     export AS="${PREFIX}/bin/${TARGET}-as"
      #     export RANLIB="${PREFIX}/bin/${TARGET}-ranlib"

      #     # mingw-crt
      #     run "prepare mingw-crt build dir" mkdir -p "${BUILD_DIR}/mingw-crt-build" && cd "${BUILD_DIR}/mingw-crt-build"
      #     run "mingw-crt: configure" "${SOURCE_CODE_DIR}/mingw-w64/mingw-w64-crt/configure" --prefix="${PREFIX}/${TARGET}" --host="${TARGET}" --build="${BUILD}" --disable-multilib --with-sysroot="${PREFIX}/${TARGET}"
      #     run "mingw-crt: make" make -j$(nproc)
      #     run "mingw-crt: install" make install

      #     # gcc full build
      #     run "取消 cross 工具链环境变量" unset CC CXX LD AR AS RANLIB
      #     run "准备 gcc full build dir" mkdir -p "${BUILD_DIR}/gcc-full-build" && cd "${BUILD_DIR}/gcc-full-build"
      #     run "gcc full: configure" "${SOURCE_CODE_DIR}/gcc/configure" \
      #       --prefix="${PREFIX}" \
      #       --target="${TARGET}" \
      #       --host="${HOST}" \
      #       --build="${BUILD}" \
      #       --disable-multilib \
      #       --enable-languages=c,c++ \
      #       --enable-threads=win32 \
      #       --enable-shared \
      #       --enable-static \
      #       --with-sysroot="${PREFIX}/${TARGET}" \
      #       --disable-nls \
      #       --with-gmp=/usr \
      #       --with-mpfr=/usr \
      #       --with-mpc=/usr \
      #       --with-isl=/usr

      #     export CC="${PREFIX}/bin/${TARGET}-gcc"
      #     export CXX="${PREFIX}/bin/${TARGET}-g++"
      #     export LD="${PREFIX}/bin/${TARGET}-ld"
      #     export AR="${PREFIX}/bin/${TARGET}-ar"
      #     export AS="${PREFIX}/bin/${TARGET}-as"
      #     export RANLIB="${PREFIX}/bin/${TARGET}-ranlib"

      #     run "gcc full: make" make -j$(nproc)
      #     run "gcc full: install" make install

      #     info "交叉编译工具链构建完成！"
      #     info "工具链已安装到：${PREFIX}"
      #     run "清除构建目录以节省空间" rm -rf "${BUILD_DIR}"

      #     # 最后：生成聚合 summary 并打印路径（actions 后续可上传）
      #     agg="$(aggregate_all_summaries)"
      #     info "聚合摘要已写入：$agg"

      # - name: upload logs
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: build-logs
      #     path: "${{ github.workspace }}/logs"

      # - name: verify cross compiler
      #   shell: bash
      #   env:
      #     GITHUB_WORKSPACE: ${{ github.workspace }}
      #     GCC_VERSION: ${{ github.event.inputs.gcc-version }}
      #   run: |
      #     export PREFIX="${GITHUB_WORKSPACE}/mingw-w64-cross"
      #     export TARGET="x86_64-w64-mingw32"

      #     ls "${PREFIX}/bin/"

      #     echo "验证交叉编译器"
      #     "${PREFIX}/bin/${TARGET}-gcc" --version
      #     "${PREFIX}/bin/${TARGET}-g++" --version

      #     echo -e "\n7.3 编译简单的C程序（验证生成Windows PE文件）"
      #     cat > test-cross.c << 'EOF'
      #     #include <stdio.h>
      #     int main() {
      #         printf("Hello from cross-compiler! This is a Windows executable.\n");
      #         return 0;
      #     }
      #     EOF

      #     # 使用交叉编译器编译
      #     "${PREFIX}/bin/${TARGET}-gcc" test-cross.c -o test-cross.exe

      #     echo "检查生成的文件类型："
      #     file test-cross.exe || true
      #     echo "文件应显示为 'PE32+ executable (console) x86-64, for MS Windows'"

      #     # 在Linux上不能运行这个.exe，但可以检查文件是否存在
      #     if [ -f "test-cross.exe" ]; then
      #         echo "✓ 成功生成了Windows可执行文件"
      #         ls -lh test-cross.exe
      #     else
      #         echo "✗ 未能生成可执行文件"
      #         exit 1
      #     fi

      #     echo -e "\n7.4 编译C++程序（验证C++支持）"
      #     cat > test-cross.cpp << 'EOF'
      #     #include <iostream>
      #     int main() {
      #         std::cout << "Hello from C++ cross-compiler!" << std::endl;
      #         return 0;
      #     }
      #     EOF

      #     "${PREFIX}/bin/${TARGET}-g++" test-cross.cpp -o test-cross-cpp.exe

      #     echo "检查C++生成的文件类型："
      #     file test-cross-cpp.exe || true

      #     echo -e "\n7.5 验证链接到mingw-w64库"
      #     cat > test-windows.c << 'EOF'
      #     #include <windows.h>
      #     #include <stdio.h>
      #     int main() {
      #         MessageBoxA(NULL, "Hello from Windows API!", "Test", MB_OK);
      #         printf("Message box should have appeared (if run on Windows)\n");
      #         return 0;
      #     }
      #     EOF

      #     "${PREFIX}/bin/${TARGET}-gcc" test-windows.c -o test-windows.exe \
      #       -Wl,--subsystem,windows

      #     echo "检查Windows GUI程序："
      #     file test-windows.exe || true

      #     echo -e "\n7.6 清理测试文件"
      #     rm -f test-cross.c test-cross.cpp test-windows.c \
      #           test-cross.exe test-cross-cpp.exe test-windows.exe

      # - name: Build native
      #   shell: bash
      #   env:
      #     GITHUB_WORKSPACE: ${{ github.workspace }}
      #     GCC_VERSION: ${{ github.event.inputs.gcc-version }}
      #   run: |
      #     set -euo pipefail
      #     source "${GITHUB_WORKSPACE}/scripts/functions.sh"

      #     # params / tuning
      #     export SOURCE_CODE_DIR="${GITHUB_WORKSPACE}/source-code"
      #     export BUILD_DIR="${GITHUB_WORKSPACE}/build-native"
      #     export CROSS_PREFIX="${GITHUB_WORKSPACE}/mingw-w64-cross"
      #     export PREFIX="${GITHUB_WORKSPACE}/mingw-w64-native"

      #     export LOG_DIR="${GITHUB_WORKSPACE}/logs"
      #     export FORCE_COLOR=1
      #     mkdir -p "${LOG_DIR}"

      #     IGNORE_REGEX='array subscript 0 is outside array bounds'
      #     LOG_TAIL_LINES=300
      #     FAIL_ON_FATAL_IN_SUCCESS=1

      #     # prepare top-level dirs
      #     for d in "${BUILD_DIR}" "${PREFIX}"; do
      #       if [ -d "${d}" ]; then
      #         run "清理目录 ${d}" rm -rf "${d}"
      #       fi
      #       run "创建目录 ${d}" mkdir -p "${d}"
      #     done

      #     cd "${BUILD_DIR}"

      #     # triples and PATH (use cross toolchain to build mingw-native artifacts)
      #     export BUILD="x86_64-pc-linux-gnu"
      #     export HOST="x86_64-w64-mingw32"
      #     export TARGET="x86_64-w64-mingw32"
      #     export PATH="${CROSS_PREFIX}/bin:${PATH}"

      #     export CC="${CROSS_PREFIX}/bin/${TARGET}-gcc"
      #     export CXX="${CROSS_PREFIX}/bin/${TARGET}-g++"
      #     export LD="${CROSS_PREFIX}/bin/${TARGET}-ld"
      #     export AR="${CROSS_PREFIX}/bin/${TARGET}-ar"
      #     export AS="${CROSS_PREFIX}/bin/${TARGET}-as"
      #     export RANLIB="${CROSS_PREFIX}/bin/${TARGET}-ranlib"

      #     # ---------- binutils (native for mingw) ----------
      #     run "准备 binutils build dir" mkdir -p "${BUILD_DIR}/binutils-build" && cd "${BUILD_DIR}/binutils-build"
      #     run "binutils: configure" "${SOURCE_CODE_DIR}/binutils/configure" \
      #       --prefix="${PREFIX}" \
      #       --host="${HOST}" \
      #       --build="${BUILD}" \
      #       --enable-static \
      #       --disable-shared
      #     run "binutils: make" make -j$(nproc)
      #     run "binutils: make install" make install

      #     # ---------- build dependencies: gmp mpfr mpc isl ----------
      #     for d in gmp mpfr mpc isl; do
      #       run "准备 ${d} build dir" mkdir -p "${BUILD_DIR}/${d}-build" && cd "${BUILD_DIR}/${d}-build"

      #       DEP_FLAGS=""
      #       if [[ "$d" == "mpfr" ]]; then
      #         DEP_FLAGS="--with-gmp=${PREFIX}"
      #       elif [[ "$d" == "mpc" ]]; then
      #         DEP_FLAGS="--with-gmp=${PREFIX} --with-mpfr=${PREFIX}"
      #       elif [[ "$d" == "isl" ]]; then
      #         DEP_FLAGS="--with-gmp-prefix=${PREFIX}"
      #       fi

      #       run "${d}: configure" "${SOURCE_CODE_DIR}/${d}/configure" \
      #         --prefix="${PREFIX}" \
      #         --host="${HOST}" \
      #         --build="${BUILD}" \
      #         ${DEP_FLAGS} \
      #         --enable-static \
      #         --disable-shared

      #       run "${d}: make" make -j$(nproc)
      #       run "${d}: make install" make install
      #     done
      #     unset DEP_FLAGS

      #     # ---------- mingw-w64 headers ----------
      #     run "准备 mingw-headers build dir" mkdir -p "${BUILD_DIR}/mingw-headers-build" && cd "${BUILD_DIR}/mingw-headers-build"
      #     run "mingw-headers: configure" "${SOURCE_CODE_DIR}/mingw-w64/mingw-w64-headers/configure" \
      #       --prefix="${PREFIX}/${TARGET}" \
      #       --host="${TARGET}" \
      #       --build="${BUILD}" \
      #       --enable-sdk=all \
      #       --enable-secure-api \
      #       --enable-idl \
      #       --disable-multilib
      #     run "mingw-headers: make" make -j$(nproc)
      #     run "mingw-headers: install" make install

      #     # ensure include symlink (same pattern as cross)
      #     run "ensure mingw include symlink" bash -lc 'mkdir -p "'"${PREFIX}/${TARGET}/mingw"'" && ln -sfn "'"${PREFIX}/${TARGET}/include"'" "'"${PREFIX}/${TARGET}/mingw/include"'"'

      #     # ---------- gcc stage1 (bootstrap minimal gcc for target) ----------
      #     run "准备 gcc stage1 build dir" mkdir -p "${BUILD_DIR}/gcc1-build" && cd "${BUILD_DIR}/gcc1-build"
      #     run "gcc stage1: configure" "${SOURCE_CODE_DIR}/gcc/configure" \
      #       --prefix="${PREFIX}" \
      #       --host="${HOST}" \
      #       --build="${BUILD}" \
      #       --disable-multilib \
      #       --enable-languages=c,c++ \
      #       --without-headers \
      #       --disable-shared \
      #       --disable-threads \
      #       --disable-libatomic \
      #       --disable-libgomp \
      #       --disable-libquadmath \
      #       --disable-libssp \
      #       --disable-libvtv \
      #       --disable-libstdcxx \
      #       --disable-nls \
      #       --with-gmp="${PREFIX}" \
      #       --with-mpfr="${PREFIX}" \
      #       --with-mpc="${PREFIX}" \
      #       --with-isl="${PREFIX}"

      #     run "gcc stage1: make all-gcc" make -j$(nproc) all-gcc
      #     run "gcc stage1: make install-gcc" make install-gcc

      #     # ---------- mingw-crt ----------
      #     run "准备 mingw-crt build dir" mkdir -p "${BUILD_DIR}/mingw-crt-build" && cd "${BUILD_DIR}/mingw-crt-build"
      #     run "mingw-crt: configure" "${SOURCE_CODE_DIR}/mingw-w64/mingw-w64-crt/configure" \
      #       --prefix="${PREFIX}/${TARGET}" \
      #       --host="${TARGET}" \
      #       --build="${BUILD}" \
      #       --disable-multilib \
      #       --with-sysroot="${PREFIX}/${TARGET}"
      #     run "mingw-crt: make" make -j$(nproc)
      #     run "mingw-crt: install" make install

      #     # ---------- gcc stage2 (full gcc using installed libs/sysroot) ----------
      #     run "取消 cross 工具链环境变量" unset CC CXX LD AR AS RANLIB
      #     run "准备 gcc stage2 build dir" mkdir -p "${BUILD_DIR}/gcc2-build" && cd "${BUILD_DIR}/gcc2-build"
      #     run "gcc stage2: configure" "${SOURCE_CODE_DIR}/gcc/configure" \
      #       --prefix="${PREFIX}" \
      #       --host="${HOST}" \
      #       --build="${BUILD}" \
      #       --target="${TARGET}" \
      #       --enable-languages=c,c++ \
      #       --enable-multilib \
      #       --disable-nls \
      #       --with-gmp="${PREFIX}" \
      #       --with-mpfr="${PREFIX}" \
      #       --with-mpc="${PREFIX}" \
      #       --with-isl="${PREFIX}"

      #     export CC="${CROSS_PREFIX}/bin/${TARGET}-gcc"
      #     export CXX="${CROSS_PREFIX}/bin/${TARGET}-g++"
      #     export LD="${CROSS_PREFIX}/bin/${TARGET}-ld"
      #     export AR="${CROSS_PREFIX}/bin/${TARGET}-ar"
      #     export AS="${CROSS_PREFIX}/bin/${TARGET}-as"
      #     export RANLIB="${CROSS_PREFIX}/bin/${TARGET}-ranlib"

      #     run "gcc stage2: make" make -j$(nproc)
      #     run "gcc stage2: make install" make install

      #     # ---------- final summary ----------
      #     info "构建完成！"
      #     info "安装目录：${PREFIX}"
      #     ls -l "${PREFIX}/bin/"

      #     # final aggregate summary
      #     agg="$(aggregate_all_summaries)"
      #     info "聚合摘要已写入：$agg"